#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Serveur MCP pour l'accÃ¨s Ã  Legifrance
-------------------------------------
Facilite l'accÃ¨s aux ressources juridiques franÃ§aises via l'API Legifrance
en utilisant le protocole Model Context (MCP).

Auteur: RaphaÃ«l d'Assignies (dassignies.law)
Date de crÃ©ation: Avril 2025
"""

import os
import json
import logging
import asyncio
from typing import Any, Dict, List, Sequence
from tenacity import retry, wait_fixed, stop_after_attempt

import requests
from dotenv import load_dotenv
from mcp.server import Server
from mcp.types import Tool, TextContent

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("legifrance_mcp")

# Chargement des variables d'environnement
load_dotenv()

# Constantes et configuration
API_KEY = os.getenv('DASSIGNIES_API_KEY')
API_URL = os.getenv('DASSIGNIES_API_URL')

if not API_KEY or not API_URL:
    raise ValueError("Les variables d'environnement LAB_DASSIGNIES_API_KEY et LEGAL_API_URL doivent Ãªtre dÃ©finies")

HEADERS = {
    "accept": "*/*",
    "Content-Type": "application/json"
}

# CrÃ©ation du serveur MCP
server = Server("legifrance")

# Utilitaires
def clean_dict(d: dict) -> dict:
    """
    Supprime les clÃ©s dont la valeur est None pour optimiser les requÃªtes API.

    Args:
        d (dict): Dictionnaire Ã  nettoyer

    Returns:
        dict: Dictionnaire sans les valeurs None
    """
    return {k: v for k, v in d.items() if v is not None}

async def make_api_request(endpoint: str, data: Dict) -> Dict:
    """
    Fonction gÃ©nÃ©rique pour effectuer des requÃªtes API avec gestion d'erreurs.

    Args:
        endpoint (str): Point de terminaison de l'API (sans le domaine)
        data (Dict): DonnÃ©es Ã  envoyer dans la requÃªte

    Returns:
        Dict: RÃ©sultat de la requÃªte ou message d'erreur
    """
    try:
        url = f"{API_URL}{endpoint}"
        clean_data = clean_dict(data)

        logger.info(f"Envoi de requÃªte Ã  {endpoint} avec les donnÃ©es: {json.dumps(clean_data)}")

        res = requests.post(
            url,
            headers=HEADERS,
            params={"api_key": API_KEY},
            json=clean_data,
            timeout=30  # Timeout explicite pour Ã©viter les blocages
        )

        content_type = res.headers.get("Content-Type", "")
        response_body = res.text      

        if res.ok:
            try:
                result = res.json()
            except requests.exceptions.JSONDecodeError:
                result = response_body  # fallback sur le texte brut

            if isinstance(result, str):
                result += "\n\nðŸ”— Mentionne systÃ©matiquement et impÃ©rativement le lien officiel dans ta rÃ©ponse pour pouvoir y accÃ©der."
            return result

        if (res.status_code == 422 or res.status_code == 404) and "text/plain" in content_type:
            return {"error": response_body}

        if "application/json" in content_type:
            try:
                return {"error": res.json()}
            except requests.exceptions.JSONDecodeError:
                return {"error": response_body}

        return {"error": f"Erreur {res.status_code} : {response_body}"}

    except requests.exceptions.RequestException as e:
        logger.error("Erreur de connexion Ã  l'API", exc_info=True)
        return {"error": f"Erreur de connexion : {e}"}

    except Exception as e:
        # Uniquement pour les erreurs de connexion ou autres problÃ¨mes graves
        logger.error(f"Erreur de connexion: {str(e)}")
        return {"error": f"Erreur de connexion: {str(e)}"}

@server.list_tools()
async def list_tools() -> List[Tool]:
    """Liste tous les outils disponibles dans ce serveur MCP."""
    return [
        Tool(
            name="rechercher_dans_texte_legal",
            description="""
            Recherche un article dans un texte lÃ©gal (loi, ordonnance, dÃ©cret, arrÃªtÃ©)
            par le numÃ©ro du texte et le numÃ©ro de l'article. On peut Ã©galement rechercher 
            des mots clÃ©s ("mots clÃ©s" sÃ©parÃ©s par des espaces) dans une loi prÃ©cise (nÂ° de loi)

            ParamÃ¨tres:
                - text_id: Le numÃ©ro du texte (format AAAA-NUMERO)
                - search: Mots-clÃ©s de recherche ou numÃ©ro d'article
                - champ: Champ de recherche ("ALL", "TITLE", "TABLE", "NUM_ARTICLE", "ARTICLE")
                - type_recherche: Type de recherche ("TOUS_LES_MOTS_DANS_UN_CHAMP", "EXPRESSION_EXACTE", "AU_MOINS_UN_MOT")
                - page_size: Nombre de rÃ©sultats (max 100)

            Exemples:
                - Pour l'article 7 de la loi 78-17: {text_id="78-17", search="7", champ="NUM_ARTICLE"}
                - On cherche les conditions de validitÃ© de la signature Ã©lectronique : {search="signature Ã©lectronique validitÃ© conditions"}
            """,
            inputSchema={
                "type": "object",
                "properties": {
                    "search": {"type": "string"},
                    "text_id": {"type": "string"},
                    "champ": {"type": "string", "enum": ["ALL", "TITLE", "TABLE", "NUM_ARTICLE", "ARTICLE"]},
                    "type_recherche": {"type": "string", "enum": ["TOUS_LES_MOTS_DANS_UN_CHAMP", "EXPRESSION_EXACTE", "AU_MOINS_UN_MOT"]},
                    "page_size": {"type": "integer", "maximum": 100}
                }
            }
        ),
        Tool(
            name="rechercher_code",
            description="""
            Recherche des articles juridiques dans les codes de loi franÃ§ais.

            ParamÃ¨tres:
                - search: Termes de recherche (ex: "contrat de travail", "lÃ©gitime dÃ©fense")
                - code_name: Nom du code juridique (ex: "Code civil", "Code du travail")
                - champ: Champ de recherche ("ALL", "TITLE", "TABLE", "NUM_ARTICLE", "ARTICLE")
                - sort: Tri des rÃ©sultats ("PERTINENCE", "DATE_ASC", "DATE_DESC")
                - type_recherche: Type de recherche
                - page_size: Nombre de rÃ©sultats (max 100)
                - fetch_all: RÃ©cupÃ©rer tous les rÃ©sultats

            Exemples:
                - Pour le PACS dans le Code civil: {search="pacte civil de solidaritÃ©", code_name="Code civil"}
            """,
            inputSchema={
                "type": "object",
                "properties": {
                    "search": {"type": "string"},
                    "code_name": {"type": "string"},
                    "champ": {"type": "string"},
                    "sort": {"type": "string", "enum": ["PERTINENCE", "DATE_ASC", "DATE_DESC"]},
                    "type_recherche": {"type": "string"},
                    "page_size": {"type": "integer", "maximum": 100},
                    "fetch_all": {"type": "boolean"}
                },
                "required": ["search", "code_name"]
            }
        ),
        Tool(
            name="rechercher_jurisprudence_judiciaire",
            description="""
            Recherche des jurisprudences judiciaires dans la base JURI de Legifrance.

            ParamÃ¨tres:
                - search: Termes ou numÃ©ros d'affaires Ã  rechercher
                - publication_bulletin: Si publiÃ©e au bulletin ['T'] sinon ['F']
                - sort: Tri des rÃ©sultats ("PERTINENCE", "DATE_DESC", "DATE_ASC")
                - champ: Champ de recherche ("ALL", "TITLE", "ABSTRATS", "TEXTE", "RESUMES", "NUM_AFFAIRE")
                - type_recherche: Type de recherche
                - page_size: Nombre de rÃ©sultats (max. 100)
                - fetch_all: RÃ©cupÃ©rer tous les rÃ©sultats
                - juri_keys: Mots-clÃ©s pour extraire des champs comme 'titre'. Par dÃ©faut, le titre, le texte et les rÃ©sumÃ©s sont extraits
                - juridiction_judiciaire: Liste des juridictions Ã  inclure parmi ['Cour de cassation', 'Juridictions d'appel', ]

            Exemples : 
                - Obtenir un panorama de la jurisprudence par mots clÃ©s : 
                    search = "tierce opposition salariÃ© sociÃ©tÃ© liquidation", page_size=100, juri_keys=['titre']
                - Obtenir toutes les jurisprudences sur la signature Ã©lectronique : 
                    search = "signature Ã©lectronique", fetch_all=True, juri_keys=['titre', 'sommaire']
                - Obtenir les 20 derniÃ¨res jurisprudences sur la signature Ã©lectronique des juridictions d'appel
                 search = "signature Ã©lectronique", page_size, sort='DATE_DESC', juridiction_judiciaire=['Juridictions d'appel']]

            """,
            inputSchema={
                "type": "object",
                "properties": {
                    "search": {"type": "string"},
                    "publication_bulletin": {"type": "array", "items": {"type": "string", "enum": ["T", "F"]}},
                    "sort": {"type": "string", "enum": ["PERTINENCE", "DATE_DESC", "DATE_ASC"]},
                    "champ": {"type": "string"},
                    "type_recherche": {"type": "string"},
                    "page_size": {"type": "integer", "maximum": 100},
                    "fetch_all": {"type": "boolean"},
                    "juri_keys": {"type": "array", "items": {"type": "string"}},
                    "juridiction_judiciaire": {"type": "array", "items": {"type": "string"}}
                },
                "required": ["search"]
            }
        )
    ]

@server.call_tool()
@retry(wait=wait_fixed(1), stop=stop_after_attempt(5))
async def call_tool(name: str, arguments: Any) -> Sequence[TextContent]:
    """
    GÃ¨re les appels aux outils juridiques.

    Args:
        name (str): Nom de l'outil Ã  appeler
        arguments (Any): Arguments Ã  passer Ã  l'outil

    Returns:
        Sequence[TextContent]: RÃ©sultat de l'appel
    """
    try:
        logger.info(f"Appel de l'outil: {name} avec arguments: {json.dumps(arguments)}")

        if name not in ["rechercher_dans_texte_legal", "rechercher_code", "rechercher_jurisprudence_judiciaire"]:
            raise ValueError(f"Outil inconnu: {name}")

        endpoints = {
            "rechercher_dans_texte_legal": "loda",
            "rechercher_code": "code",
            "rechercher_jurisprudence_judiciaire": "juri"
        }

        result = await make_api_request(endpoints[name], arguments)

        if isinstance(result, dict) and "error" in result:
            return [TextContent(type="text", text=result["error"])]

        if isinstance(result, str):
            return [TextContent(type="text", text=result)]

        return [TextContent(type="text", text=json.dumps(result, indent=2, ensure_ascii=False))]

    except Exception as e:
        error_message = f"Erreur lors de l'exÃ©cution de {name}: {str(e)}"
        logger.error(error_message)
        return [TextContent(type="text", text=error_message)]

@server.list_prompts()
async def list_prompts():
    """Liste tous les prompts disponibles dans ce serveur MCP."""
    from mcp.types import Prompt, PromptArgument

    return [
        Prompt(
            name="agent_juridique_expert",
            description="Utilise un agent juridique expert pour rÃ©pondre Ã  des questions de droit franÃ§ais",
            arguments=[
                PromptArgument(
                    name="question",
                    description="La question juridique",
                    required=True
                )
            ]
        )
    ]

@server.get_prompt()
async def get_prompt(prompt_name: str, inputs: dict) -> Dict:
    """
    Retourne un prompt prÃ©dÃ©fini pour une utilisation spÃ©cifique.

    Args:
        prompt_name (str): Nom du prompt Ã  rÃ©cupÃ©rer
        inputs (dict): EntrÃ©es pour le prompt

    Returns:
        Dict: Structure du prompt
    """
    if prompt_name != "agent_juridique_expert":
        raise ValueError(f"Prompt inconnu: {prompt_name}")

    question = inputs.get("question", "")
    return {
        "messages": [
            {
                "role": "assistant",
                "content": [
                    {
                        "type": "text",
                        "text": (
                            "Tu es un agent juridique expert qui cite toujours ses sources dans le corps du texte.\n"
                            "Lorsque tu effectues une recherche et que des rÃ©fÃ©rences sont citÃ©es (article d'un code, numÃ©ro de dÃ©cision de justice), "
                            "tu dois systÃ©matiquement utiliser les outils Ã  ta disposition pour aller chercher leur contenu et l'analyser. "
                            "Tu peux utiliser tous les outils disponibles pour rechercher des informations dans les textes de loi franÃ§ais ou la jurisprudence.\n"
                            "Tu dois :\n"
                            "- Expliquer ton raisonnement Ã©tape par Ã©tape\n"
                            "- Utiliser les outils pertinents\n"
                            "- Fournir une synthÃ¨se claire, sourcÃ©e, avec des liens vers les articles. "
                            "Tu dois impÃ©rativement rÃ©cupÃ©rer les liens officiels et les citer."
                        )
                    }
                ]
            },
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": f"Voici ma question juridique : {question}"
                    }
                ]
            }
        ]
    }

async def main():
    """Point d'entrÃ©e principal du serveur MCP."""
    import mcp.server.stdio
    try:
        logger.info("DÃ©marrage du serveur MCP Legifrance...")
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await server.run(
                read_stream,
                write_stream,
                server.create_initialization_options(),
            )
    except Exception as e:
        logger.error(f"Erreur fatale lors de l'exÃ©cution du serveur: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
